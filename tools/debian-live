#! /bin/bash

#
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#

#
# Copyright 2020 Joyent, Inc.
#

#
# This is an initial crude hack that generates a debian live image that includes
# zfs.  Thanks to https://willhaley.com/blog/custom-debian-live-environment/ for
# making this problem easily approachable.
#
# WARNING:   This script generates an image that taints the kernel with CDDL
#	     licensed zfs modules.  Many believe that distribution of the binary
#	     zfs modules infringe on the GPLv2 licensed Linux code.
#	     Distribution of images generated with this script is highly
#	     discouraged.
#

export PATH=/bin:/usr/bin:/usr/sbin

PS4='${FUNCNAME:-debian-live}: '
set -euo pipefail

debver=buster
name="Debian 10"
docurl=https://github.com/joyent/linux-live

# Where does /usr/node come from?
manta_url=${MANTA_URL:-https://us-east.manta.joyent.com}
node_manta_dir=/Joyent_Dev/public/bits/linuxcn
node_archive=sdcnode-v8.16.1-linux-63d6e664-3f1f-11e8-aef6-a3120cf8dd9d-linuxcn-20191231T144917Z-gdd5749b.tgz

ntp=0.debian.pool.ntp.org
zfs_ver=0.8.2		# XXX really master until log spacemap is in a release

# From https://willhaley.com/blog/custom-debian-live-environment/
packages=(linux-image-amd64 live-boot systemd-sysv)
packages+=(net-tools openssh-client)

# For set-hostid, sysinfo, etc.
packages+=(dmidecode python3)

# I noticed these important things are missing
packages+=(openssh-server vim curl less ca-certificates iproute2 man
   dnsutils iputils-ping sysstat sudo strace lsof psmisc pcp)

# These will be installed while zfs is built, then removed.  Unnecessary
# dependencies will also be removed.
zfs_build_packages=(gawk alien libblkid-dev uuid-dev libudev-dev libssl-dev
    zlib1g-dev libaio-dev libattr1-dev libelf-dev python3-setuptools
    python3-cffi libffi-dev git build-essential gdebi linux-headers-amd64
    dpkg-dev fakeroot debhelper git dkms python3-dev
)

# Args added to 'apt install'
apt_args=(-y)
apt_args+=(--no-install-recommends)

#
# No more configuration
#

clean=()
function cleanup {
	local i=${#clean[@]}

	while (( $i > 0 )); do
		(( i-- ))
		eval ${clean[i]}
	done
}
trap cleanup EXIT

clean_exit=false
function onfatal {
	if [[ $clean_exit == false ]]; then
		echo "Cleaning up: $@" 1>&2
		eval "$@"
	fi
}

function unmount_children {
	local dirs=($(mount | awk -v root=$root/ '
	BEGIN {
		if ( root == "/" || root == "" ) {
			printf "cleanup: root is \"%s\"\n", root >/dev/fd/2
			exit 1
		}
	}
	$3 ~ root {
		print $3
	}' | sort -r))
	for dir in "${dirs[@]}"; do
		umount "$dir"
	done
}

# Ensure we have all the commands that will be needed
function preflight_check {
	local cmds
	typeset -A cmds
	cmds["mcopy"]=mtools
	cmds["mksquashfs"]=squashfs-tools
	cmds["xorriso"]=xorriso
	cmds["efibootmgr"]=grub-efi
	cmds["mkfs.vfat"]=dosfstools
	cmds["pigz"]=pigz
	cmds["kpartx"]=kpartx

	missing=()
	for cmd in ${!cmds[@]}; do
		if ! type -path "$cmd" >/dev/null 2>&1; then
			echo "$0: missing command $cmd" 1>&2
			missing+=(${cmds["$cmd"]})
		fi
	done
	if (( ${#missing[@]} != 0 )); then
		exec 1>&2
		echo "$0: Missing ${#missing[@]} packages."
		echo ""
		echo "To fix, run:"
		echo "    apt install -y ${missing[@]}"
		exit 1
	fi
}

function create_bootstrap {
	zfs create $dataset
	#clean+=("onfatal zfs destroy $dataset")
	debootstrap --arch=amd64 --variant=minbase "$debver" "$root" \
	    http://ftp.us.debian.org/debian/
}

function install_live {
	chroot "$root" tee /etc/apt/sources.list >/dev/null <<-EOF
	deb http://deb.debian.org/debian/ $debver main
	deb-src http://deb.debian.org/debian/ $debver main

	deb http://security.debian.org/debian-security $debver/updates main
	deb-src http://security.debian.org/debian-security $debver/updates main

	deb http://deb.debian.org/debian/ $debver-updates main
	deb-src http://deb.debian.org/debian/ $debver-updates main
	EOF

	chroot "$root" tee /etc/apt/sources.list.d/$debver-backports.list \
	    >/dev/null <<-EOF
	# https://github.com/zfsonlinux/zfs/wiki/Debian#installation
	deb http://deb.debian.org/debian $debver-backports main contrib
	deb-src http://deb.debian.org/debian $debver-backports main contrib
	EOF

	chroot "$root" tee /etc/apt/preferences.d/90_zfs >/dev/null <<-EOF
	# https://github.com/zfsonlinux/zfs/wiki/Debian#installation
	Package: libnvpair1linux libuutil1linux libzfs2linux libzpool2linux spl-dkms zfs-dkms zfs-test zfsutils-linux zfsutils-linux-dev zfs-zed
	Pin: release n=buster-backports
	Pin-Priority: 990
	EOF

	chroot "$root" apt update
	chroot "$root" env DEBIAN_FRONTEND=noninteractive apt install \
	    "${apt_args[@]}" "${packages[@]}" "${zfs_build_packages[@]}"
}

function build_zfs {
	clean+=(unmount_children)
	mount -t proc proc $root/proc

	chroot "$root" bash -c '
	    PS4="BUILD_ZFS: "
	    set -xeuo pipefail

	    export DEBIAN_FRONTEND=noninteractive
	    export LC_ALL=C

	    rm -rf zfs
	    git clone https://github.com/zfsonlinux/zfs.git
	    cd zfs
	    ./autogen.sh
	    ./configure
	    make -j1 pkg-utils deb-kmod
	    for file in *.deb; do gdebi -q --non-interactive $file; done
	    cd ..
	    rm -rf zfs
	'

	umount $root/proc
}

# In the previous "apt install" we built the zfs kernel modules, which brought
# in over 100 MiB of development tools.  Now, generate a binary deb containing
# the zfs kernel modules built from zfs-dkms, uninstall all the development
# stuff, and install the non-dkms binary zfs module.
function reduce_zfs {
	chroot "$root" env zfs_ver="$zfs_ver" pkgs="${zfs_build_packages[*]}" \
	    bash -c '
		PS4="CLEAN_ZFS_DEV: "
		set -xeuo pipefail

		export DEBIAN_FRONTEND=noninteractive
		export LC_ALL=C

		apt remove -y $pkgs "kernel-headers-*"
		apt autoremove -y

		rm -f /tmp/zfs-modules-*.deb
	'
}

# As much as possible, bits that are needed to support Triton will appear in
# /usr/triton.
function install_usr_triton {
	chroot "$root" mkdir -p /usr/triton
	curl "$manta_url/$node_manta_dir/$node_archive" |
	    chroot "$root" tar -C /usr/triton --no-same-owner -xzf -
	chroot "$root" ln -sf triton/node /usr/
}

function install_proto {
	# cpio is used for creating the archive because it will take a list of
	# files from stdin.  tar is used for extracting it because it will
	# create any required directories automatically.  The directories are
	# not included because we don't want to accidentally change the
	# permissions on directories that already exist.
	#
	# XXX consider transitioning to use of a manifest and install(1) for
	# better control.
	(cd "$repo/proto" && find . -type d -o -print | cpio -o -H ustar) |
	    (chroot "$root" /usr/bin/tar --no-same-owner -xvf -)
}

function postinstall {
	# Heavily inspired by mi-debian-hvm/debian-10/late-command
	chroot "$root" env release="$release" motd="$motd" product="$product" \
	    bash -c '
		PS4="POSTINSTALL: "
		set -xeuo pipefail

		echo debian-live-$release >/etc/hostname

		apt-get autoremove --purge -y
		apt-get clean

		rm -rf /var/lib/apt/lists/*
		rm -rf /var/cache/*
		rm -f /etc/machine-id /etc/hostid

		passwd -d root

		# For crazy quoting reasons we rely on $motd and $product from
		# env
		echo "$motd" >/etc/motd
		ln -sf /etc/motd /etc/issue
		ln -sf /etc/motd /etc/issue.net
		echo "$product" >/etc/product

		find /etc/ssh -name "ssh_host_*key*" -exec rm -f "{}" ";"
		sed -i -e "s,^#HostKey /etc/ssh/,HostKey /var/ssh/," \
		    -e "s,^#\(PermitRootLogin prohibit-password\),\1," \
		    /etc/ssh/sshd_config

		rm -f /*.old

		# Being live media, /etc/zfs/zpool.cache is not present/useful.
		systemctl enable zfs-import-scan.service

		# The root home directory has nothing useful in it. Removing it
		# makes it possible to have a dataset mounted on /root, thereby
		# easily preserving ssh authorized_keys and such.
		rm -rf /root
		mkdir -m 700 /root

		# As above, clean cruft here.
		rm -f /etc/sudoers.d/*
	    '
}

function prepare_archive_bits {
	mkdir -p $scratch $image/live
	mksquashfs $root $image/live/filesystem.squashfs -noappend -e boot
	cp $root/boot/vmlinuz-* $image/vmlinuz
	cp $root/boot/initrd.img-* $image/initrd

	cat <<EOF >$scratch/grub.cfg
search --set=root --file /JOYENT_DEBIAN_LIVE

insmod all_video

set default="0"
set timeout=30

menuentry "Joyent Debian Live $release" {
    linux /vmlinuz boot=live
    initrd /initrd
}
EOF
	echo $release > $image/JOYENT_DEBIAN_LIVE
}

function create_iso {
	grub-mkstandalone --format=x86_64-efi --output=$scratch/bootx64.efi \
	    --locales="" --fonts="" "boot/grub/grub.cfg=$scratch/grub.cfg"

	grub-mkstandalone --format=i386-pc --output=$scratch/core.img \
	    --install-modules="linux normal iso9660 biosdisk memdisk search tar ls" \
	    --modules="linux normal iso9660 biosdisk search" --locales="" \
	    --fonts="" "boot/grub/grub.cfg=$scratch/grub.cfg"

	# mcopy, mmd from mtools - Not Manta!
	(cd $scratch && \
	    dd if=/dev/zero of=efiboot.img bs=1M count=10 && \
	    mkfs.vfat efiboot.img && \
	    mmd -i efiboot.img efi efi/boot && \
	    mcopy -i efiboot.img ./bootx64.efi ::efi/boot/
	)

	cat /usr/lib/grub/i386-pc/cdboot.img $scratch/core.img > \
	    $scratch/bios.img

	xorriso -as mkisofs -iso-level 3 -full-iso9660-filenames \
	    -volid "JOYENT_DEBIAN_LIVE" -eltorito-boot boot/grub/bios.img \
	    -no-emul-boot -boot-load-size 4 -boot-info-table \
	    --eltorito-catalog boot/grub/boot.cat --grub2-boot-info \
	    --grub2-mbr /usr/lib/grub/i386-pc/boot_hybrid.img \
	    -eltorito-alt-boot -e EFI/efiboot.img -no-emul-boot \
	    -append_partition 2 0xef $scratch/efiboot.img \
	    -output "$top/joyent-debian_live-$release.iso" \
	    -graft-points "$image" /boot/grub/bios.img=$scratch/bios.img \
	    /EFI/efiboot.img=$scratch/efiboot.img
}

# Creates a USB disk that should be bootable with bios or uefi. The parition
# containing the image is over sized by about 20% for metadata and a bit of
# breathing room.  Those that want to store more stuff on it can grow the
# partition and file system to use the available space.
function create_usb {
	local skip_sec=2048
	local bios_start=$skip_sec
	local bios_sec=2048
	local bios_end=$(( bios_start + bios_sec - 1 ))
	local esp_start=$(( bios_end + 1 ))
	local esp_sec=409600
	local esp_end=$(( esp_start + esp_sec - 1 ))
	local esp_mnt=$scratch/mnt/esp
	local image_start=$(( esp_end + 1 ))
	local image_sec=$(du -sk $image | awk '{print $1 * 2 * 1.2}')
	local image_mnt=$scratch/mnt/image
	local total_sec=$(( image_start + image_sec ))
	local disk_mb=$(( total_sec / 2 / 1024 + 1 ))
	local disk_file=$scratch/joyent-debian_live-$release.usb

	truncate -s "$disk_mb"M "$disk_file"

	parted --script "$disk_file" mklabel gpt \
	    mkpart primary fat32 ${bios_start}s ${bios_end}s \
		name 1 BIOS set 1 bios_grub on \
	    mkpart ESP fat32 ${esp_start}s ${esp_end}s \
		name 2 EFI set 2 esp on \
	    mkpart primary fat32 ${image_start}s 100% \
		name 3 LINUX set 3 msftdata on

	gdisk "$disk_file" <<-EOF
	r     # recovery and transformation options
	h     # make hybrid MBR
	1 2 3 # partition numbers for hybrid MBR
	N     # do not place EFI GPT (0xEE) partition first in MBR
	EF    # MBR hex code
	N     # do not set bootable flag
	EF    # MBR hex code
	N     # do not set bootable flag
	83    # MBR hex code
	Y     # set the bootable flag
	x     # extra functionality menu
	h     # recompute CHS values in protective/hybrid MBR
	w     # write table to disk and exit
	Y     # confirm changes
	EOF

	local parts=$(kpartx -s -v -a "$disk_file")
	cleanup+=("kpartx -d $disk_file")

	esp_dev=$(echo "$parts" | awk -v start=$esp_start \
	    '$1 == "add" && $NF == start {
		printf "/dev/mapper/%s", $3;
		exit 0
	    }')
	image_dev=$(echo "$parts" | awk -v start=$image_start \
	    '$1 == "add" && $NF == start {
		printf "/dev/mapper/%s", $3;
		exit 0
	    }')
	if [[ -z $esp_dev || -z $image_dev ]]; then
		echo "$0: failed to find partitions in usb dev" 1>&2
		exit 1
	fi

	# Create and mount FAT32 file systems on partitions 2 and 3.  Partition
	# 1 is not touched.
	mkdir -p "$esp_mnt" "$image_mnt"

	mkfs.vfat -F32 "$esp_dev"
	mount "$esp_dev" "$esp_mnt"
	cleanup+=("onfatal umount $esp_dev")

	mkfs.vfat -F32 "$image_dev"
	mount "$image_dev" "$image_mnt"
	cleanup+=("onfatal umount $image_dev")

	grub-install --target=x86_64-efi \
	    --efi-directory=$esp_mnt --boot-directory=$image_mnt/boot \
	    --removable --recheck

	grub-install --target=i386-pc --boot-directory=$image_mnt/boot \
	    --recheck "$disk_file"

	mkdir -p $image_mnt/boot/grub $image_mnt/live
	cp -r $image/* "$image_mnt"
	cp $scratch/grub.cfg $image_mnt/boot/grub/grub.cfg

	umount "$image_mnt"
	umount "$esp_mnt"

	rm -f "$top/joyent-debian_live-$release.usb.gz"
	pigz -c "$disk_file" > "$top/joyent-debian_live-$release.usb.gz"
}

function run {
	local step=$1
	local presnap=$dataset@pre-$step
	local postsnap=$dataset@post-$step

	if zfs list -Ho name "$presnap" >/dev/null 2>&1; then
		zfs rollback -r "$presnap"
	elif zfs list -Ho name "$dataset" >/dev/null 2>&1; then
		zfs snapshot "$presnap"
	fi

	$step

	if zfs list -Ho name "$dataset" >/dev/null 2>&1; then
		zfs snapshot $postsnap
	fi
}

function fail_usage {
	exec 1>&2
	echo "Usage:"
	echo "Create a new iamge from scratch"
	echo "    debian-live"
	echo ""
	echo "Run just the specified steps on an existing image build"
	echo "    debian-live -r release step [...]"
	echo ""
	echo "Valid steps are:"
	printf "    %s\n" "${all_steps[@]}" ...
	echo ""
	echo "Literal ... may be used to specify all remaining steps."
	exit 1
}

exec </dev/null

release=$(TZ=UTC date +%Y%m%dT%H%M%SZ)
all_steps=(preflight_check
    create_bootstrap
    install_live
    build_zfs
    reduce_zfs
    install_usr_triton
    install_proto
    postinstall
    prepare_archive_bits
    create_iso
    create_usb)

while getopts r:x opt; do
	case $opt in
	r)	release=$OPTARG ;;
	x)	set -x ;;
	*)	fail_usage ;;
	esac
done
shift $(( $OPTIND - 1 ))
if (( $# == 0 )); then
	steps=("${all_steps[@]}")
else
	steps=()
	prev=
	for step in $@; do
		if [[ $step != ... ]]; then
			steps+=($step)
			prev=$step
			continue
		fi
		for step in "${all_steps[@]}"; do
			if [[ $step == $prev ]]; then
				prev=_found_it
				continue
			fi
			if [[ $prev == _found_it ]]; then
				steps+=($step)
			fi
		done
	done
fi

dataset=data/debian-live-$release
top=/$dataset
root=$top/chroot
image=$top/image
scratch=$top/scratch
repo=$(git rev-parse --show-toplevel)

motd=$'
   __        .                   .
 _|  |_      | .-. .  . .-. :--. |-
|_    _|     ;|   ||  |(.-\' |  | |
  |__|   `--\'  `-\' `;-| `-\' \'  \' `-\'
                   /  ;  Platform ('"$name"' '"$release"$')
                   `-\'   '"$docurl"'
'

commit=$(cd $(dirname "$0") && git rev-parse HEAD)
product="
Name: Joyent Platform Image
Image: $name $release
Documentation: https://github.com/joyent/linux-live/
Description: $name with zfs $zfs_ver.  THIS IMAGE IS NOT REDISTRIBUTABLE with the zfs kernel modules.
Commit: https://github.com/joyent/linux-live/commit/$commit
"

for step in "${steps[@]}"; do
	run $step
done

clean_exit=true
set +x

ls -lh $top/*.iso $top/*.usb.gz 2>/dev/null || :
